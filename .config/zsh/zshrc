#!/bin/zsh

umask 022

# if it's a dumb terminal, return.
if [[ ${TERM} == 'dumb' ]]; then
	return
fi
[[ $- =~ i ]] || return

# Use emacs keybindings even if our EDITOR is set to vi
bindkey -e

# enable all of the highlighters
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor root)

# secrets
source-with-force ~/.zsh/secrets

# Set up the prompt
autoload -Uz ztheme; ztheme

if [[ -z $ZSH_CACHE_DIR ]]; then
	echo "- ZSH_CACHE_DIR is not set?" >&2
	return 1
elif [[ ! -e $ZSH_CACHE_DIR ]]; then
	echo "- Creating ZSH_CACHE_DIR=\"$ZSH_CACHE_DIR\"" >&2
	mkdir -pv $ZSH_CACHE_DIR
fi

##
## Queue loads via mocking them.
## We'll run them once we have the full list if necessary.
## Avoids races and dependency woes since now we can order accordingly.
##

# Reset zplug queue
typeset -a ZPLUGINS_Q=()

function zplugins.load() {
	set -- $1
	ZPLUGINS_Q+=(${(q)argv} $'\0')
}

##
## Zplugins loader API
##

function zplugins.load-all-in() {
	local p

	local paths=()
	for p in "$@"; do
		if [[ ${p:0:1} == / ]]; then
			paths+=($p(-/N))
		else
			paths+=(${^ZDOTDIRS}/$p(-/N))
		fi
	done

	local defer
	for p in ${^paths}/*(-/N); do
		defer=${${p:t}%%[^0-9]*}
		if [[ -n $defer ]]; then
			defer=$defer
		else
			defer=0
		fi

		zplugins.load $p --from local --defer $defer
	done
}

##
## Collect plugins
##

# Stub antibody that just queues the commands for later
function antibody() {
	zplugins.load "$@"
}

# Checks newest mtime to see if cache needs to be regenerated.
ZPLUGINS_CHECK=($ZSH_CACHE_DIR/zplugins.bundle(-.N))
# Plugin sources
ZPLUGINS_FILES=(${^ZDOTDIRS}/zshplugins(-.N))
# Collect plugin list
source-with-force $ZPLUGINS_FILES

# Remove stub
unfunction antibody

##
## Now we can apply them as necessary upon first call transparently.
## Avoids races and dependency woes since now we can order accordingly.
##

function zplugins.antibody.init-hooks() {
	if ! (( ${+commands[antibody]} )); then
		echo "- Antibody not found in path. Cannot/will not continue. Deal with it." >&2
		echo "  >> go get -u -x -v github.com/getantibody/antibody" >&2
		return 1
	fi

	source <(command antibody init)
}

function zplugins.lazy.bundle() {
	command antibody bundle "${(0)ZPLUGINS_Q}"
}

function zplugins.lazy.apply() {
	source <(
		zplugins.lazy.bundle \
		| tee $ZSH_CACHE_DIR/zplugins.bundle
	)
}

#function zplugins.antibody.stub.apply {
#    unfunction antibody
#    zplugins.lazy.apply

#    #zplugins.antibody.init

#    ! (( $# )) || antibody "$@"
#}

#function antibody() {
#    zplugins.antibody.stub.apply "$@"
#}

##
## Cache validation
##

function max() {
	local sorted=(${(n)argv})
	[[ $#sorted -eq 0 ]] \
		|| echo ${sorted[-1]}
}

function min() {
	local sorted=(${(n)argv})
	[[ $#sorted -eq 0 ]] \
		|| echo ${sorted[1]}
}

zmodload -F zsh/stat b:zstat

function zplugins.cache.is-clean() {
	if [ ! -d $ZPLUG_CACHE_DIR ]; then
		echo "- Cache dir not found: $ZPLUG_CACHE_DIR" >&2
		return 1
	fi

	if [[ ${#ZPLUGINS_FILES} -eq 0 ]] || [[ ${#ZPLUGINS_CHECK} -eq 0 ]]; then
		echo "- No files found to check cache mtimes: ($ZPLUGINS_CHECK) ($ZPLUGINS_FILES)" >&2
		return 2
	fi

	local files_mtime=$(max $(zstat -N +mtime $ZPLUGINS_FILES))
	local check_mtime=$(max $(zstat -N +mtime $ZPLUGINS_CHECK))
	if [[ $files_mtime -gt $check_mtime ]]; then
		echo "- Detected change in plugins: $files_mtime $check_mtime" >&2
		return 100
	fi
}

##
## Check cache
##

#if zplugins.cache.is-clean; then
#    source-with-force $ZPLUGINS_CACHE
#else
#    echo "- Creating cache (may take a second)"
#    antibody <(
#    zplugins.lazy.apply
#fi

zplugins.lazy.apply

##
## Real mode
##

# local
source-with-force $LOCAL_ZDOTDIR/zshrc

# This is annoying to have earlier.
#setopt warncreateglobal

autoload -Uz fix-{f,}path-order
fix-path-order
fix-fpath-order

